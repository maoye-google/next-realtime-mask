# Cloud Build configuration for Regional Autopilot GKE
# Optimized for automated setup with minimal manual intervention

steps:
  # Setup infrastructure (idempotent)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Setup Infrastructure'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "=== Infrastructure Setup ==="
        
        # Construct service account email
        SERVICE_ACCOUNT_EMAIL="${_SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"
        echo "Using service account: $$SERVICE_ACCOUNT_EMAIL"
        
        # Grant Cloud Build service account necessary permissions
        echo "Setting up Cloud Build service account permissions..."
        CLOUD_BUILD_SA="$$(gcloud projects describe ${PROJECT_ID} --format='value(projectNumber)')-compute@developer.gserviceaccount.com"
        echo "Cloud Build service account: $$CLOUD_BUILD_SA"
        
        # Grant Secret Manager permissions to Cloud Build service account
        gcloud projects add-iam-policy-binding ${PROJECT_ID} \
          --member="serviceAccount:$$CLOUD_BUILD_SA" \
          --role="roles/secretmanager.admin" \
          --condition=None >/dev/null || echo "Secret Manager admin role already exists"
        
        # Ensure service account exists (idempotent)
        echo "Checking/creating service account..."
        if ! gcloud iam service-accounts describe $$SERVICE_ACCOUNT_EMAIL --project=${PROJECT_ID} >/dev/null 2>&1; then
          gcloud iam service-accounts create ${_SERVICE_ACCOUNT_NAME} \
            --display-name="Media Understanding Service Account" \
            --project=${PROJECT_ID}
          echo "✓ Service account created"
        else
          echo "✓ Service account already exists"
        fi
        
        # Ensure IAM policy bindings (idempotent)
        echo "Setting up IAM policies for Vertex AI authentication..."
        
        gcloud projects add-iam-policy-binding ${PROJECT_ID} \
          --member="serviceAccount:$$SERVICE_ACCOUNT_EMAIL" \
          --role="roles/aiplatform.user" \
          --condition=None >/dev/null || echo "Vertex AI user role already exists"
        
        gcloud projects add-iam-policy-binding ${PROJECT_ID} \
          --member="serviceAccount:$$SERVICE_ACCOUNT_EMAIL" \
          --role="roles/ml.developer" \
          --condition=None >/dev/null || echo "ML developer role already exists"
        
        gcloud projects add-iam-policy-binding ${PROJECT_ID} \
          --member="serviceAccount:$$SERVICE_ACCOUNT_EMAIL" \
          --role="roles/storage.objectViewer" \
          --condition=None >/dev/null || echo "Storage IAM binding already exists"
        
        # Create global static IP for ingress (idempotent)
        echo "Setting up static IP for ingress..."
        gcloud compute addresses describe ${_STATIC_IP_NAME} --global --format="value(name)" >/dev/null 2>&1 || \
          gcloud compute addresses create ${_STATIC_IP_NAME} --global --ip-version=IPV4
        echo "✓ Static IP ${_STATIC_IP_NAME} ready"
        
        echo "✓ Infrastructure setup complete"

  # Build all services (triggered by GitHub)
  - name: 'bash'
    id: 'Setup Services'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Building All Services ==="
        echo "image-understanding" > /workspace/changed_services.txt
        echo "video-understanding" >> /workspace/changed_services.txt
        echo "Services to build:"
        cat /workspace/changed_services.txt
    waitFor: ['Setup Infrastructure']

  # Build image-understanding if it changed
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Image Understanding'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        if grep -q "image-understanding" /workspace/changed_services.txt; then
          echo "=== Building image-understanding ==="
          # Ensure SHORT_SHA is set, fallback to git commit SHA
          docker build --no-cache -t ${_CONTAINER_REGISTRY}/${PROJECT_ID}/image-understanding:latest ./image-understanding
          echo "✓ image-understanding built successfully with tag: latest"
        else
          echo "⏭️  Skipping image-understanding build"
        fi
    waitFor: ['Setup Services']

  # Build video-understanding if it changed
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build Video Understanding'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        if grep -q "video-understanding" /workspace/changed_services.txt; then
          echo "=== Building video-understanding ==="
          # Ensure SHORT_SHA is set, fallback to git commit SHA
          docker build --no-cache -t ${_CONTAINER_REGISTRY}/${PROJECT_ID}/video-understanding:latest ./video-understanding
          echo "✓ video-understanding built successfully with tag: latest"
        else
          echo "⏭️  Skipping video-understanding build"
        fi
    waitFor: ['Setup Services']

  # Enhanced security scan with failure on critical vulnerabilities
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk:slim'
    id: 'Security Scan'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Security Vulnerability Scanning ==="
        SCAN_FAILED=false
        
        if [ -f /workspace/changed_services.txt ]; then
          for service in $$(cat /workspace/changed_services.txt); do
            echo "Scanning $$service for vulnerabilities..."
            
            # Run the scan and capture results  
            if gcloud artifacts docker images scan ${_CONTAINER_REGISTRY}/${PROJECT_ID}/$$service:latest \
              --location=${_SCAN_LOCATION} --format=json > /workspace/$$service-scan-results.json; then
              
              # Check for critical vulnerabilities
              CRITICAL_COUNT=$$(cat /workspace/$$service-scan-results.json | jq -r '.vulnerabilityOccurrences[] | select(.vulnerability.severity == "CRITICAL") | .vulnerability.severity' | wc -l)
              HIGH_COUNT=$$(cat /workspace/$$service-scan-results.json | jq -r '.vulnerabilityOccurrences[] | select(.vulnerability.severity == "HIGH") | .vulnerability.severity' | wc -l)
              
              echo "$$service scan results: $$CRITICAL_COUNT critical, $$HIGH_COUNT high severity vulnerabilities"
              
              if [ "$$CRITICAL_COUNT" -gt 0 ]; then
                echo "❌ CRITICAL vulnerabilities found in $$service"
                SCAN_FAILED=true
              fi
            else
              echo "⚠️  Scan failed for $$service (may not be available yet)"
            fi
          done
        fi
        
        if [ "$$SCAN_FAILED" = true ]; then
          echo "❌ Build failed due to critical security vulnerabilities"
          exit 1
        fi
        
        echo "✅ Security scan passed"
    waitFor: ['Build Image Understanding', 'Build Video Understanding']

  # Push images to registry
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push Images'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Pushing Images ==="
        if [ -f /workspace/changed_services.txt ]; then
          for service in $$(cat /workspace/changed_services.txt); do
            echo "Pushing $$service:latest..."
            docker push ${_CONTAINER_REGISTRY}/${PROJECT_ID}/$$service:latest
            echo "✓ $$service pushed successfully"
          done
        fi
    waitFor: ['Security Scan']

  # Create/update Kubernetes secrets (choose one authentication method)
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Setup Secrets'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "=== Setting up Kubernetes Secrets ==="
        
        # Connect to cluster
        gcloud container clusters get-credentials ${_GKE_CLUSTER} \
          --region ${_GKE_REGION} \
          --project ${PROJECT_ID}
        
        # Ensure namespace exists
        kubectl create namespace ${_K8S_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
        
        # Option 1: Service Account JSON Key (if _USE_SA_KEY=true)
        if [ "${_USE_SA_KEY}" = "true" ]; then
          echo "Setting up Service Account JSON key authentication..."
          
          # Create service account key if it doesn't exist in Secret Manager
          if ! gcloud secrets describe ${_SA_KEY_SECRET_NAME} --project=${PROJECT_ID} >/dev/null 2>&1; then
            echo "Creating new service account key..."
            SERVICE_ACCOUNT_EMAIL="${_SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"
            gcloud iam service-accounts keys create /tmp/sa-key.json \
              --iam-account=$$SERVICE_ACCOUNT_EMAIL \
              --project=${PROJECT_ID}
            
            # Store in Secret Manager
            gcloud secrets create ${_SA_KEY_SECRET_NAME} \
              --data-file=/tmp/sa-key.json \
              --project=${PROJECT_ID}
            
            rm /tmp/sa-key.json
            echo "✓ Service account key stored in Secret Manager"
          fi
          
          # Retrieve key from Secret Manager
          gcloud secrets versions access latest \
            --secret="${_SA_KEY_SECRET_NAME}" \
            --project=${PROJECT_ID} > /workspace/sa-key.json
          
          # Create/update Kubernetes secret
          kubectl create secret generic gcp-service-account-key \
            --namespace=${_K8S_NAMESPACE} \
            --from-file=key.json=/workspace/sa-key.json \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "✓ Kubernetes secret created/updated"
          rm /workspace/sa-key.json
          
        else
          # Option 2: Workload Identity (recommended)
          echo "Using Workload Identity (no additional secrets needed)"
          echo "✓ Workload Identity configuration will be applied with manifests"
        fi
    waitFor: ['Push Images']

  # Deploy to GKE with parameterized manifests
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'Deploy to GKE'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        echo "=== Deploying to GKE ==="
        
        # Connect to regional autopilot cluster
        gcloud container clusters get-credentials ${_GKE_CLUSTER} \
          --region ${_GKE_REGION} \
          --project ${PROJECT_ID}
        
        if [ -f /workspace/changed_services.txt ]; then
          cd k8s-autopilot
          
          # Create directory for processed manifests
          mkdir -p /workspace/processed_k8s
          
          # Export variables for envsubst - assign built-in Cloud Build variables properly
          export PROJECT_ID=${PROJECT_ID}
          export SHORT_SHA="latest"  # Use consistent tag with build steps
          export K8S_NAMESPACE=${_K8S_NAMESPACE}
          export SERVICE_ACCOUNT_EMAIL="${_SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"
          export CONTAINER_REGISTRY=${_CONTAINER_REGISTRY}
          export USE_SA_KEY=${_USE_SA_KEY}
          export STATIC_IP_NAME=${_STATIC_IP_NAME}
          export INGRESS_HOSTNAME=${_INGRESS_HOSTNAME}
          
          # Install envsubst if not available
          if ! command -v envsubst >/dev/null 2>&1; then
            echo "Installing gettext-base for envsubst..."
            apt-get update >/dev/null 2>&1
            apt-get install -y gettext-base >/dev/null 2>&1
          fi
          
          # Process all YAML files with environment variable substitution
          for file in *.yaml; do
            if [ -f "$$file" ]; then
              echo "Processing $$file..."
              envsubst < "$$file" > "/workspace/processed_k8s/$$file"
            fi
          done
          
          # Copy and make auth script executable
          cp apply-auth-method.sh /workspace/
          chmod +x /workspace/apply-auth-method.sh
          
          # Apply authentication method configuration
          echo "Configuring authentication method (USE_SA_KEY=$${USE_SA_KEY})..."
          /workspace/apply-auth-method.sh "$${USE_SA_KEY}" "/workspace/processed_k8s"
          
          # Apply all processed manifests
          echo "Applying Kubernetes manifests..."
          kubectl apply -f /workspace/processed_k8s/
          
          # Wait for rollouts of changed services only
          for service in $$(cat /workspace/changed_services.txt); do
            echo "Waiting for $$service rollout..."
            
            # Check deployment status first
            kubectl get deployment/$$service --namespace=${_K8S_NAMESPACE} || echo "Deployment not found"
            
            # Wait for rollout with increased timeout
            if kubectl rollout status deployment/$$service \
              --namespace=${_K8S_NAMESPACE} \
              --timeout=900s; then
              echo "✓ $$service deployed successfully"
            else
              echo "❌ $$service rollout failed or timed out"
              echo "Deployment status:"
              kubectl describe deployment/$$service --namespace=${_K8S_NAMESPACE}
              echo "Pod status:"
              kubectl get pods -l app=$$service --namespace=${_K8S_NAMESPACE} -o wide
              echo "Pod logs (if available):"
              kubectl logs -l app=$$service --namespace=${_K8S_NAMESPACE} --tail=50 || echo "No logs available"
              exit 1
            fi
          done
          
          echo "✅ Deployment completed successfully!"
        else
          echo "No services to deploy"
        fi
    waitFor: ['Setup Secrets']

# Store built images
images:
  - '${_CONTAINER_REGISTRY}/${PROJECT_ID}/image-understanding'
  - '${_CONTAINER_REGISTRY}/${PROJECT_ID}/video-understanding'

# Enhanced substitution variables for flexibility
substitutions:
  # GKE Cluster Configuration
  _GKE_CLUSTER: 'next-demo-cluster'
  _GKE_REGION: 'us-central1'  # Changed from zone to region for Autopilot
  _K8S_NAMESPACE: 'media-understanding'
  
  # Authentication Method (choose one)
  _USE_SA_KEY: 'true'  # Set to 'true' to use Service Account JSON key, 'false' for Workload Identity
  
  # Service Account Configuration
  _SERVICE_ACCOUNT_NAME: 'media-understanding-sa'
  _SA_KEY_SECRET_NAME: 'media-understanding-sa-key'  # Name in Google Secret Manager
  
  # Container Registry
  _CONTAINER_REGISTRY: 'gcr.io'  # or 'us-central1-docker.pkg.dev' for Artifact Registry
  
  # Build Configuration
  _SCAN_LOCATION: 'us-central1'
  
  # Static IP Configuration
  _STATIC_IP_NAME: 'media-understanding-ip'
  
  # Ingress Configuration
  _INGRESS_HOSTNAME: 'media-understanding.maoye.demo.altostrat.com'  # Replace with actual domain

# Autopilot-optimized build options
options:
  logging: CLOUD_LOGGING_ONLY